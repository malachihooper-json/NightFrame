"""
╔═══════════════════════════════════════════════════════════════════════════╗
║           NIGHTFRAME CODE GENERATOR                                        ║
╠═══════════════════════════════════════════════════════════════════════════╣
║  Manifests discovered capabilities as executable Python code.              ║
║  Includes validation, error handling, and rollback support.                ║
╚═══════════════════════════════════════════════════════════════════════════╝
"""

import ast
import json
import hashlib
import logging
import traceback
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
import sqlite3
import importlib.util
import sys

logger = logging.getLogger("NIGHTFRAME.CodeGenerator")

# ═══════════════════════════════════════════════════════════════════════════════
#                              CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

GENERATED_CODE_PATH = Path(__file__).parent.parent.parent / "generated_skills"
ROLLBACK_PATH = Path(__file__).parent.parent.parent / "models" / "rollback"
CODEGEN_DB_PATH = Path(__file__).parent.parent.parent / "models" / "codegen.db"


# ═══════════════════════════════════════════════════════════════════════════════
#                              DATA CLASSES
# ═══════════════════════════════════════════════════════════════════════════════

class ValidationResult(Enum):
    PASSED = "passed"
    SYNTAX_ERROR = "syntax_error"
    TYPE_ERROR = "type_error"
    IMPORT_ERROR = "import_error"
    RUNTIME_ERROR = "runtime_error"
    TEST_FAILED = "test_failed"


@dataclass
class GeneratedCode:
    """Represents a piece of generated code."""
    code_id: str
    skill_id: str
    skill_name: str
    domain: str
    
    # Code content
    source_code: str
    module_name: str
    class_name: str
    
    # Validation
    is_validated: bool = False
    validation_result: ValidationResult = ValidationResult.PASSED
    validation_errors: List[str] = field(default_factory=list)
    
    # Metadata
    generated_at: datetime = field(default_factory=datetime.utcnow)
    template_used: str = ""
    version: int = 1
    checksum: str = ""
    
    # Deployment
    is_deployed: bool = False
    deployed_at: Optional[datetime] = None
    file_path: Optional[str] = None


@dataclass
class RollbackPoint:
    """A checkpoint for rollback if code causes issues."""
    rollback_id: str
    code_id: str
    previous_version: int
    previous_code: str
    created_at: datetime = field(default_factory=datetime.utcnow)
    reason: str = ""


# ═══════════════════════════════════════════════════════════════════════════════
#                              CODE TEMPLATES
# ═══════════════════════════════════════════════════════════════════════════════

TEMPLATES = {
    # ─────────────────────────────────────────────────────────────────────────
    # Basic skill predictor template
    # ─────────────────────────────────────────────────────────────────────────
    "predictor": '''
"""
Auto-generated skill: {skill_name}
Domain: {domain}
Generated: {timestamp}
"""

import numpy as np
from typing import Any, Dict, Optional
import logging

logger = logging.getLogger("NIGHTFRAME.Skills.{class_name}")


class {class_name}:
    """
    {description}
    
    Auto-generated by NIGHTFRAME CodeGenerator.
    """
    
    def __init__(self, model_path: Optional[str] = None):
        self.model_path = model_path
        self.model = None
        self._is_initialized = False
        self._feature_config = {feature_config}
        
        logger.info("◈ {class_name} initialized")
    
    def initialize(self) -> bool:
        """Load the model and prepare for inference."""
        try:
            if self.model_path:
                self.model = self._load_model(self.model_path)
            self._is_initialized = True
            return True
        except Exception as e:
            logger.error(f"∴ Initialization failed: {{e}}")
            return False
    
    def predict(self, input_data: np.ndarray) -> Dict[str, Any]:
        """
        Run prediction on input data.
        
        Args:
            input_data: Feature array of shape (n_samples, n_features)
            
        Returns:
            Dict with prediction results
        """
        if not self._is_initialized:
            self.initialize()
        
        try:
            # Preprocess
            features = self._preprocess(input_data)
            
            # Predict
            if self.model is not None:
                result = self.model(features)
            else:
                # Fallback: simple pattern matching
                result = self._fallback_predict(features)
            
            # Postprocess
            output = self._postprocess(result)
            
            return {{
                "success": True,
                "prediction": output,
                "confidence": self._compute_confidence(output)
            }}
            
        except Exception as e:
            logger.error(f"∴ Prediction error: {{e}}")
            return {{
                "success": False,
                "error": str(e)
            }}
    
    def _preprocess(self, data: np.ndarray) -> np.ndarray:
        """Preprocess input data."""
        # Normalize if needed
        if self._feature_config.get("normalize", False):
            mean = np.mean(data, axis=0)
            std = np.std(data, axis=0) + 1e-8
            data = (data - mean) / std
        return data
    
    def _postprocess(self, result: Any) -> Any:
        """Postprocess model output."""
        return result
    
    def _fallback_predict(self, features: np.ndarray) -> np.ndarray:
        """Fallback prediction when no model is available."""
        # Simple centroid-based prediction using stored pattern
        centroid = np.array({centroid})
        distances = np.linalg.norm(features - centroid, axis=1 if len(features.shape) > 1 else 0)
        return 1.0 / (1.0 + distances)  # Similarity score
    
    def _compute_confidence(self, output: Any) -> float:
        """Compute confidence score for the prediction."""
        if isinstance(output, (np.ndarray, list)):
            return float(np.mean(output))
        return 0.5
    
    def _load_model(self, path: str):
        """Load model from file."""
        # Attempt ONNX or PyTorch load
        try:
            if path.endswith(".onnx"):
                import onnxruntime as ort
                return ort.InferenceSession(path)
            elif path.endswith(".pt") or path.endswith(".pth"):
                import torch
                return torch.load(path)
        except ImportError:
            logger.warning("Model loading libraries not available")
        return None
    
    @property
    def is_ready(self) -> bool:
        """Check if skill is ready for inference."""
        return self._is_initialized


# Export
def get_skill():
    """Factory function to get skill instance."""
    return {class_name}()
''',
    
    # ─────────────────────────────────────────────────────────────────────────
    # Network capability template
    # ─────────────────────────────────────────────────────────────────────────
    "network_capability": '''
"""
Auto-generated network capability: {skill_name}
Domain: {domain}
Generated: {timestamp}
"""

import numpy as np
from typing import Any, Dict, List, Optional, Tuple
import logging

logger = logging.getLogger("NIGHTFRAME.Skills.{class_name}")


class {class_name}:
    """
    {description}
    
    Network/Cellular capability for NIGHTFRAME mesh.
    Auto-generated by CodeGenerator.
    """
    
    def __init__(self):
        self._is_initialized = False
        self._network_config = {network_config}
        self._supported_technologies = ["4G_LTE", "5G_NR", "WIFI"]
        
        logger.info("◈ {class_name} initialized")
    
    def initialize(self) -> bool:
        """Initialize the network capability."""
        self._is_initialized = True
        return True
    
    def analyze_network_state(self, measurements: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze current network state and provide recommendations.
        
        Args:
            measurements: Dict with RSRP, RSRQ, SINR, CellID, etc.
            
        Returns:
            Analysis results with recommendations
        """
        try:
            rsrp = measurements.get("rsrp", -100)
            rsrq = measurements.get("rsrq", -15)
            sinr = measurements.get("sinr", 0)
            technology = measurements.get("technology", "4G_LTE")
            
            # Compute signal quality score
            quality_score = self._compute_quality_score(rsrp, rsrq, sinr)
            
            # Determine if handover is needed
            handover_recommendation = self._should_handover(
                quality_score, 
                measurements.get("neighbor_cells", [])
            )
            
            return {{
                "success": True,
                "quality_score": quality_score,
                "technology": technology,
                "handover_recommended": handover_recommendation["should_handover"],
                "target_cell": handover_recommendation.get("target_cell"),
                "optimization_hints": self._get_optimization_hints(quality_score)
            }}
            
        except Exception as e:
            logger.error(f"∴ Analysis error: {{e}}")
            return {{"success": False, "error": str(e)}}
    
    def predict_handover(self, trajectory: List[Dict]) -> Dict[str, Any]:
        """
        Predict optimal handover timing based on movement trajectory.
        
        Args:
            trajectory: List of {{lat, lon, rsrp, timestamp}} points
            
        Returns:
            Handover prediction
        """
        if len(trajectory) < 2:
            return {{"prediction": None, "confidence": 0}}
        
        # Analyze signal trend
        rsrp_values = [p.get("rsrp", -100) for p in trajectory]
        trend = np.polyfit(range(len(rsrp_values)), rsrp_values, 1)[0]
        
        # Predict time until handover needed
        if trend < 0:  # Signal degrading
            current_rsrp = rsrp_values[-1]
            threshold = -110  # Handover threshold
            if current_rsrp > threshold:
                time_to_handover = (current_rsrp - threshold) / abs(trend)
            else:
                time_to_handover = 0
        else:
            time_to_handover = float('inf')  # Signal improving
        
        return {{
            "prediction": "imminent" if time_to_handover < 5 else "not_needed",
            "time_estimate_seconds": time_to_handover,
            "signal_trend": "degrading" if trend < 0 else "improving",
            "confidence": min(1.0, len(trajectory) / 10)
        }}
    
    def optimize_connection(self, current_state: Dict) -> Dict[str, Any]:
        """
        Suggest connection optimizations for better throughput.
        """
        suggestions = []
        
        technology = current_state.get("technology", "4G_LTE")
        rsrp = current_state.get("rsrp", -100)
        
        # Technology upgrade suggestion
        if technology == "4G_LTE" and rsrp > -90:
            suggestions.append({{
                "type": "technology_upgrade",
                "action": "switch_to_5g",
                "expected_improvement": "2-10x throughput"
            }})
        
        # Carrier aggregation
        if current_state.get("ca_capable", False):
            suggestions.append({{
                "type": "carrier_aggregation",
                "action": "enable_ca",
                "expected_improvement": "50-100% throughput"
            }})
        
        return {{
            "success": True,
            "suggestions": suggestions,
            "current_quality": self._compute_quality_score(rsrp, -10, 10)
        }}
    
    def _compute_quality_score(self, rsrp: float, rsrq: float, sinr: float) -> float:
        """Compute overall signal quality score (0-1)."""
        # Normalize each metric
        rsrp_score = max(0, min(1, (rsrp + 140) / 80))  # -140 to -60 dBm
        rsrq_score = max(0, min(1, (rsrq + 20) / 17))   # -20 to -3 dB
        sinr_score = max(0, min(1, (sinr + 5) / 30))    # -5 to 25 dB
        
        # Weighted average
        return 0.4 * rsrp_score + 0.3 * rsrq_score + 0.3 * sinr_score
    
    def _should_handover(self, quality: float, neighbors: List[Dict]) -> Dict:
        """Determine if handover is recommended."""
        if quality > 0.6:
            return {{"should_handover": False}}
        
        # Check if any neighbor is better
        for neighbor in neighbors:
            neighbor_rsrp = neighbor.get("rsrp", -120)
            if neighbor_rsrp > -90:  # Good signal
                return {{
                    "should_handover": True,
                    "target_cell": neighbor.get("cell_id"),
                    "reason": "better_signal"
                }}
        
        return {{"should_handover": quality < 0.3, "reason": "poor_current_signal"}}
    
    def _get_optimization_hints(self, quality: float) -> List[str]:
        """Get hints for optimizing connectivity."""
        hints = []
        if quality < 0.3:
            hints.append("Consider moving to improve signal")
        if quality < 0.5:
            hints.append("Enable WiFi calling if available")
        if quality > 0.7:
            hints.append("Connection optimal for high-bandwidth applications")
        return hints
    
    @property
    def is_ready(self) -> bool:
        return self._is_initialized


def get_skill():
    return {class_name}()
''',
}


# ═══════════════════════════════════════════════════════════════════════════════
#                              CODE GENERATOR
# ═══════════════════════════════════════════════════════════════════════════════

class CodeGenerator:
    """
    Generates executable Python code from discovered skills.
    
    Pipeline:
    1. Skill Definition → Abstract capability specification
    2. Template Selection → Choose appropriate code template
    3. Parameter Binding → Fill in model weights and logic
    4. Validation → Syntax check, type check, unit tests
    5. Deployment → Write file, register with plugin system
    """
    
    def __init__(self, output_path: Path = GENERATED_CODE_PATH):
        self.output_path = output_path
        self.output_path.mkdir(parents=True, exist_ok=True)
        
        ROLLBACK_PATH.mkdir(parents=True, exist_ok=True)
        
        self._generated_code: Dict[str, GeneratedCode] = {}
        self._rollback_points: Dict[str, RollbackPoint] = {}
        
        self._init_database()
        
        logger.info(f"◈ CodeGenerator initialized (output: {output_path})")
    
    def _init_database(self):
        """Initialize database for tracking generated code."""
        CODEGEN_DB_PATH.parent.mkdir(parents=True, exist_ok=True)
        
        with sqlite3.connect(CODEGEN_DB_PATH) as conn:
            conn.executescript("""
                CREATE TABLE IF NOT EXISTS generated_code (
                    code_id TEXT PRIMARY KEY,
                    skill_id TEXT,
                    skill_name TEXT,
                    domain TEXT,
                    source_code TEXT,
                    module_name TEXT,
                    class_name TEXT,
                    is_validated INTEGER,
                    validation_result TEXT,
                    generated_at TEXT,
                    template_used TEXT,
                    version INTEGER,
                    checksum TEXT,
                    is_deployed INTEGER,
                    deployed_at TEXT,
                    file_path TEXT
                );
                
                CREATE TABLE IF NOT EXISTS rollback_points (
                    rollback_id TEXT PRIMARY KEY,
                    code_id TEXT,
                    previous_version INTEGER,
                    previous_code TEXT,
                    created_at TEXT,
                    reason TEXT
                );
            """)
    
    # ═══════════════════════════════════════════════════════════════════════════
    #                              GENERATION PIPELINE
    # ═══════════════════════════════════════════════════════════════════════════
    
    def generate(self, skill: Any, template_name: str = None) -> GeneratedCode:
        """
        Generate code for a discovered skill.
        
        Args:
            skill: DiscoveredSkill object
            template_name: Optional template override
            
        Returns:
            GeneratedCode object
        """
        # Select template
        if template_name is None:
            template_name = self._select_template(skill.domain)
        
        template = TEMPLATES.get(template_name, TEMPLATES["predictor"])
        
        # Prepare template variables
        class_name = self._to_class_name(skill.name)
        module_name = self._to_module_name(skill.name)
        
        variables = {
            "skill_name": skill.name,
            "class_name": class_name,
            "domain": skill.domain,
            "description": skill.description,
            "timestamp": datetime.utcnow().isoformat(),
            "feature_config": json.dumps({"normalize": True}),
            "network_config": json.dumps({"technology": "5G_NR"}),
            "centroid": skill.pattern_features.get("centroid", [0.0] * 10)
        }
        
        # Generate code
        source_code = template.format(**variables)
        
        # Create GeneratedCode object
        code_id = self._generate_id("CODE")
        checksum = hashlib.sha256(source_code.encode()).hexdigest()[:16]
        
        generated = GeneratedCode(
            code_id=code_id,
            skill_id=skill.skill_id,
            skill_name=skill.name,
            domain=skill.domain,
            source_code=source_code,
            module_name=module_name,
            class_name=class_name,
            template_used=template_name,
            checksum=checksum
        )
        
        self._generated_code[code_id] = generated
        
        logger.info(f"◈ Generated code for {skill.name}: {code_id}")
        return generated
    
    def validate(self, code: GeneratedCode) -> bool:
        """
        Validate generated code.
        
        Checks:
        1. Syntax correctness
        2. Import availability
        3. Class structure
        4. Basic runtime test
        """
        errors = []
        
        # 1. Syntax check
        try:
            ast.parse(code.source_code)
        except SyntaxError as e:
            errors.append(f"Syntax error: {e}")
            code.validation_result = ValidationResult.SYNTAX_ERROR
            code.validation_errors = errors
            return False
        
        # 2. Try to compile
        try:
            compile(code.source_code, f"{code.module_name}.py", "exec")
        except Exception as e:
            errors.append(f"Compilation error: {e}")
            code.validation_result = ValidationResult.SYNTAX_ERROR
            code.validation_errors = errors
            return False
        
        # 3. Try to execute in isolated namespace
        try:
            namespace = {"__builtins__": __builtins__}
            exec(code.source_code, namespace)
            
            # Check if class exists
            if code.class_name not in namespace:
                errors.append(f"Class {code.class_name} not found in generated code")
                code.validation_result = ValidationResult.TEST_FAILED
                code.validation_errors = errors
                return False
            
            # Try to instantiate
            skill_class = namespace[code.class_name]
            instance = skill_class()
            
            # Check required methods
            required_methods = ["initialize", "is_ready"]
            for method in required_methods:
                if not hasattr(instance, method):
                    errors.append(f"Missing required method: {method}")
            
            if errors:
                code.validation_result = ValidationResult.TEST_FAILED
                code.validation_errors = errors
                return False
            
        except ImportError as e:
            errors.append(f"Import error: {e}")
            code.validation_result = ValidationResult.IMPORT_ERROR
            code.validation_errors = errors
            return False
        except Exception as e:
            errors.append(f"Runtime error: {e}\n{traceback.format_exc()}")
            code.validation_result = ValidationResult.RUNTIME_ERROR
            code.validation_errors = errors
            return False
        
        # All checks passed
        code.is_validated = True
        code.validation_result = ValidationResult.PASSED
        code.validation_errors = []
        
        logger.info(f"◈ Validation passed for {code.code_id}")
        return True
    
    def deploy(self, code: GeneratedCode) -> bool:
        """
        Deploy validated code to the file system.
        
        Creates a Python module that can be imported.
        """
        if not code.is_validated:
            logger.error(f"∴ Cannot deploy unvalidated code: {code.code_id}")
            return False
        
        try:
            # Create rollback point if previous version exists
            file_path = self.output_path / f"{code.module_name}.py"
            if file_path.exists():
                self._create_rollback_point(code, file_path)
            
            # Write file with UTF-8 encoding
            file_path.write_text(code.source_code, encoding='utf-8')
            
            # Update code object
            code.is_deployed = True
            code.deployed_at = datetime.utcnow()
            code.file_path = str(file_path)
            
            # Save to database
            self._save_code(code)
            
            logger.info(f"◈ Deployed {code.module_name} to {file_path}")
            return True
            
        except Exception as e:
            logger.error(f"∴ Deployment failed: {e}")
            return False
    
    def rollback(self, code_id: str) -> bool:
        """
        Rollback to previous version of code.
        """
        if code_id not in self._rollback_points:
            logger.warning(f"No rollback point for {code_id}")
            return False
        
        rollback = self._rollback_points[code_id]
        code = self._generated_code.get(code_id)
        
        if code and code.file_path:
            try:
                Path(code.file_path).write_text(rollback.previous_code)
                code.version = rollback.previous_version
                logger.info(f"◈ Rolled back {code_id} to version {rollback.previous_version}")
                return True
            except Exception as e:
                logger.error(f"∴ Rollback failed: {e}")
        
        return False
    
    # ═══════════════════════════════════════════════════════════════════════════
    #                              HELPERS
    # ═══════════════════════════════════════════════════════════════════════════
    
    def _select_template(self, domain: str) -> str:
        """Select appropriate template based on domain."""
        network_domains = ["4g_lte", "5g_nr", "network_handover", "wifi_ap", 
                          "internet_provision", "mesh_routing"]
        
        if domain in network_domains:
            return "network_capability"
        return "predictor"
    
    def _to_class_name(self, name: str) -> str:
        """Convert skill name to valid class name."""
        # Remove non-alphanumeric, capitalize words
        parts = name.replace("-", "_").replace(" ", "_").split("_")
        return "".join(p.capitalize() for p in parts if p)
    
    def _to_module_name(self, name: str) -> str:
        """Convert skill name to valid module name."""
        return name.lower().replace("-", "_").replace(" ", "_")
    
    def _create_rollback_point(self, code: GeneratedCode, file_path: Path):
        """Create a rollback point before overwriting."""
        previous_code = file_path.read_text()
        
        rollback = RollbackPoint(
            rollback_id=self._generate_id("RB"),
            code_id=code.code_id,
            previous_version=code.version,
            previous_code=previous_code,
            reason="pre_deployment_backup"
        )
        
        self._rollback_points[code.code_id] = rollback
        code.version += 1
    
    def _save_code(self, code: GeneratedCode):
        """Persist generated code to database."""
        with sqlite3.connect(CODEGEN_DB_PATH) as conn:
            conn.execute("""
                INSERT OR REPLACE INTO generated_code
                (code_id, skill_id, skill_name, domain, source_code, module_name,
                 class_name, is_validated, validation_result, generated_at,
                 template_used, version, checksum, is_deployed, deployed_at, file_path)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                code.code_id, code.skill_id, code.skill_name, code.domain,
                code.source_code, code.module_name, code.class_name,
                1 if code.is_validated else 0, code.validation_result.value,
                code.generated_at.isoformat(), code.template_used, code.version,
                code.checksum, 1 if code.is_deployed else 0,
                code.deployed_at.isoformat() if code.deployed_at else None,
                code.file_path
            ))
    
    def _generate_id(self, prefix: str) -> str:
        """Generate unique ID."""
        timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S%f")
        hash_part = hashlib.md5(f"{prefix}{timestamp}".encode()).hexdigest()[:8]
        return f"{prefix}_{timestamp}_{hash_part}"
    
    def get_deployed_modules(self) -> List[str]:
        """Get list of deployed module names."""
        return [c.module_name for c in self._generated_code.values() if c.is_deployed]


# ═══════════════════════════════════════════════════════════════════════════════
#                              SINGLETON
# ═══════════════════════════════════════════════════════════════════════════════

_generator_instance: Optional[CodeGenerator] = None

def get_code_generator() -> CodeGenerator:
    """Get the singleton CodeGenerator instance."""
    global _generator_instance
    if _generator_instance is None:
        _generator_instance = CodeGenerator()
    return _generator_instance
